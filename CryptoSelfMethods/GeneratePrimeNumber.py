import random


def generate_prime(N):
    """Генерация простого числа"""
    m = N // 2  # Генерация случайного числа
    n = random.randint(2, m)  # из интервала 2..N/2
    n = 2 * n - 1  # Получение нечетного случайного числа

    # Пока число не простое, продолжаем генерировать
    while is_prime(n) != True:
        m = N // 2  # Генерация случайного числа
        n = random.randint(2, m)  # из интервала 2..N/2
        n = 2 * n - 1  # Получение нечетного случайного числа
    return n


def is_prime(n):
    """Тест на проверку простоты числа с помощью решета Эратосфена, иначе тест Рабина-Миллера"""
    p = eratosphen(810)

    m = len(p)

    # Сравнение сгенерированного числа n с первыми 150 простыми числами
    for i in range(m):
        # Проверка делится ли число n на одно из первых простых чисел
        if n % p[i] == 0:
            # Если сгенерированное число n является одним
            # из первых простых чисел,
            if n == p[i]:
                return True  # то n - простое
            else:
                return False  # иначе n - составное

    r = 60  # Количество повторений теста Рабина-Миллера
    return rabin_miller(n, r)


def eratosphen(n):
    """Генерирует решето Эратосфена"""
    a = []

    # Получение списка заполненного 1
    for j in range(n + 1):
        a.append(1)

    j = 2
    # Просматриваем все числа меньше n
    while j * j <= n:
        # Если число не вычеркнуто, то оно - простое
        if a[j] == 1:
            i = j * j
            # Вычеркиваются все числа кратные j
            while i <= n:
                a[i] = 0
                i = i + j
        j = j + 1

    p = []

    # Получаем список простых чисел
    for j in range(2, n + 1):
        if a[j] == 1:
            p.append(j)

    return p


def rabin_miller(n, r):
    """Тест Рабина-Миллера для проверки простоты числа"""
    b = n - 1
    k = -1
    beta = []

    # Получение двоичное записи числа b
    k = k + 1
    beta.append(b % 2)
    b = b // 2
    while b > 0:
        k = k + 1
        beta.append(b % 2)
        b = b // 2

    # Повторяем метод Рабина-Миллера r раз
    for j in range(r):
        a = random.randint(2, n - 1)  # Получаем случайное основание a
        # Проверяем взаимную простоту a и n
        if euclid(a, n) > 1:
            return False
        # Возведение числа a в степень n-1
        # с помощью метода повторного возведения
        # в квадрат с использованием рекуррентного соотношения
        # и проверки на нетривиальный корень из 1
        d = 1
        for i in range(k, -1, -1):
            x = d
            d = d * d % n  # Получение остатка от деления на n
            # Проверка на нетривиальный корень из 1
            if d == 1 and x != 1 and x != n - 1:
                return False
            # Рекуррентное соотношение
            if beta[i] == 1:
                d = d * a % n
        # Если НОД(a,n) не равен 1
        if d != 1:
            return False  # n - составное
    return True


def euclid(a, b):
    """Алгоритм Евклида для нахождения НОД"""
    if b == 0:
        return a
    return euclid(b, a % b)
